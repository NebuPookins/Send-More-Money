package net.nebupookins.akka.sendmoremoney
 
import akka.actor._
import akka.routing.RoundRobinRouter

import com.typesafe.config._

import java.io.File

import scala.collection._
import scala.io.Source

object SendMoreMoney {
  /*
   * The general architecture of this app is that SendMoreMoney is the object
   * containing the def main(args: Array[String]) entry point which simply does
   * some minimal checks of the application.conf file, and then launches the
   * actor system, spawning only the Master actor. The Master actor is then
   * responsible for spawning all the other actors.
   *
   * The other actors are:
   *
   *  * The SumCheckers (by default, one actor per CPU core) which verify
   *    whether there exists a solution to the three-word equation.
   *  * The FrequencyChecker, which verifies that the three-word sequence has
   *    at least one example usage (e.g. on Twitter)
   *  * The ResultPrinter, which prints valid puzzles to standard out.
   *
   * All the non-Master actors simply communicate with whoever sent them a
   * message. As such, they have no dependencies on any other actors, and are
   * thus easier to unit test. In a normal run of the application, the sender
   * is always the Master actor.
   */

  /**
   * Main entry-point into the application.
   *
   * @param args ignored. All configuration is done via the application.conf file.
   */
  def main(args: Array[String]) {
    /*
     * This function gets configuration via the Typesafe-config library (so
     * usually, this data will come from the application.conf file), then goes
     * down into the "send-more-money" section (i.e. ignoring the akka section),
     * and it's this inner appConfig that gets passed around everywhere.
     *
     * The function then checks that the twitter-authentication section has been
     * filled out, and if not, exits early, informing the user on standard-error
     * that they must fill out that section.
     *
     * If the twitter information is present, this function starts the actor
     * system, and creates the Master actor, and then sends the Master actor the
     * "start" message, indicating it should start working.
     */
    val rootConf: Config = ConfigFactory.load()
    val appConf: Config = rootConf.getConfig("send-more-money")
    if (
      appConf.getString("twitter-authentication.consumer-key") == "XXX" ||
      appConf.getString("twitter-authentication.consumer-secret") == "XXX" ||
      appConf.getString("twitter-authentication.access-token") == "XXX" ||
      appConf.getString("twitter-authentication.access-token-secret") == "XXX"
    ) {
      System.err.println("You must edit the application.conf file and fill in")
      System.err.println("the values for the consumer-key, consumer-secret,")
      System.err.println("access-token and access-token-secret under the")
      System.err.println("twitter-authentication section. Instructions for how")
      System.err.println("to do this are provided in the application.conf file.")
    } else {
      val system = ActorSystem("SendMoreMoneySystem")
      val master = system.actorOf(Props(new Master(appConf)), name = "master")
      master ! Start
    }
  }

  /**
   * SMMMessage is the super type of all messages defined in this app. 
   */
  sealed trait SMMMessage
  /**
   * The Start message is intended to be sent to the Master actor to indicate
   * that the work should start.
   */
  case object Start extends SMMMessage
  /**
   * AddProof is not a message in itself, but acts as a component to a message.
   * It represents a proof that an equation is valid by demonstrating a solution
   * to the equation. Under normal circumstances, these proofs are generated by
   * a SumChecker actor, and verified by the other actors.
   */
  case class AddProof(operand1: Long, operand2: Long, total: Long)
  /**
   * PotentialMatch is the workhorse of the messages. It contains the three-word
   * equation, with optionally a proof of equation-validity, and a proof of
   * usage by humans.
   *
   * It's both generated and read by almost every actor.
   */
  case class PotentialMatch(
    operand1: String, operand2: String, total: String,
    /**
     * Optional proof of equation validity. None indicates that we don't know if
     * the equation is valid or not. Some(Set.empty) indicates that we know
     * these words do NOT form a valid equation. Some(non-empty Set) indicates
     * that these words DO form a valid equation, with all the solutions that
     * were found.
     */
    addProofs: Option[Set[AddProof]],
    usageProof: Option[String]
  ) extends SMMMessage

  /**
   * The AddChecked message is generated by the SumChecker actors to inform the
   * sender (usually the Master actor) that they have finished checking a
   * PotentialMatch for validity.
   */
  case object AddChecked extends SMMMessage //TODO: Make this wrap a PotentialMatch?

  /**
   * The UsageChecked message is generated by the FrequencyChecker actor to
   * inform the sender (usually the Master actor) that they have finished
   * checking a PotentialMatch for usage by humans.
   */
  case object UsageChecked extends SMMMessage //TODO: Make this wrap a PotentialMatch?

  /**
   * The ResultPrinted message is generated by the ResultPrinter actor to inform
   * the sender (usually the Master actor) that they have printed the
   * PotentialMatch to the user.
   */
  case object ResultPrinted extends SMMMessage //TODO: Make this wrap a PotentialMatch?

  /**
   * The Master Actor takes in a Configuration object specifying details like
   * what dictionary file to read from, what the Twitter authentication info
   * is, etc., and then arranges to generate SEND+MORE=MONEY puzzles (mainly
   * by delegating to child actors)
   */
  class Master(appConf: Config) extends Actor with ActorLogging {
    /*
     * The Master actor is also in charge of enforcing global level rules that
     * were set in the configuration. For example, it will enfore the
     * minimum-word-length rule, and the allow-non-unique-solutions rule.
     */

    /*
     * The mastor actor starts by reading all the relevant information from the
     * configuration file. It will print a warning if the configuration states
     * to use fewer SumChecker workers than there are CPU cores, but will
     * proceed anyway.
     */
    val numSumCheckers = appConf.getInt("number-of-sum-checkers")
    val minimumWordLength = appConf.getInt("minimum-word-length")
    val allowDuplicateOperands = appConf.getBoolean("allow-duplicate-operand")
    val allowNonUniqueSolutions = appConf.getBoolean("allow-non-unique-solutions")
    val numProcessors = Runtime.getRuntime().availableProcessors()
    if (numSumCheckers < numProcessors) {
      log.warning(
        "WARNING: You have set the number of Sum Checkers to be %d, but you seem to ".format(numSumCheckers) +
        "have %d cores available. You may achieve higher parallelism and thus ".format(numProcessors) +
        "higher performance is you increase the number of Sum Checkers in the " +
        "application.conf file."
      )
    }

    /*
     * It then filters to dictionary list to only keep those which exist,
     * printing a warning for each file that does not exist.
     */
    val wordFiles: List[File] = {
      import scala.collection.JavaConverters._
      val tempWordFiles = for(
        fileName: String <- appConf.getStringList("dictionary-files").asScala.toList
      ) yield {
        new File(fileName).getAbsoluteFile
      }
      val (existing, nonExisting) = tempWordFiles.partition(_.exists())
      for (file <- nonExisting) {
        log.warning("Could not find file %s. Skipping it.".format(file))
      }
      existing
    }
    /*
     * It then reads in these files, filtering out words that are shorter than
     * minimum-word-length, and normalizing the casing to be all UPPERCASE.
     */
    val words: Set[String] = {
      log.info("Received files: %s ".format(wordFiles))
      val temp: Traversable[String] = (for (file <- wordFiles) yield {
        log.info("Processing %s...".format(file))
        val lines: Iterator[String] = Source.fromFile(file, "UTF-8").getLines
        lines
      }).flatten.filter(_.length >= minimumWordLength)
      assert(temp.nonEmpty, "temp.size == %d".format(temp.size)) //TODO: Handle empty word list?
      temp.map(_.toUpperCase).toSet
    }
    assert(words.nonEmpty, "words.size == %d".format(words.size)) //TODO: Handle empty word list?
    /*
     * It generates all of its child actors.
     */
    val sumCheckerRouter = context.actorOf(
        Props.empty.withRouter(RoundRobinRouter(routees = {
          for (_ <- 0 until numSumCheckers) yield context.actorOf(Props(new SumChecker(appConf)))
        })), name = "SumCheckerRouter")
    val freqchecker = context.actorOf(Props(new FrequencyChecker(appConf)), name = "FrequencyChecker")
    val resultPrinter = context.actorOf(Props(new ResultPrinter(appConf)), name = "ResultPrinter")

    /*
     * It has a set of counters to check when all the jobs are finished. Every
     * time it sends out a job, it increments the appropriate wordsSent counter,
     * and when the results received equals the jobs sent, it knows all the work
     * is done.
     *
     * TODO: This assumes that message delivery is guaranteed. Refactor to
     * support dropped messages?
     */
    var wordsSentToAddCheck = 0
    var wordsAddChecked = 0
    var wordsSentToUsageCheck = 0
    var wordsUsageChecked = 0
    var wordsSentToResultPrinter = 0
    var resultsPrinted = 0

    val logShutdownChecks = appConf.getBoolean("logging.master.shutdown-checks")

    /**
     * checkShutdown determines whether all the jobs are complete by comparing
     * the number of job request sent with the number of responses received. If
     * they match, it invokes the Akka `system.shutdown()` call which shutsdown
     * the actor system.
     */
    def checkShutdown() {
      if (logShutdownChecks) {
        log.debug(
          "Checking shutdown. add: %d == %d? usage: %d == %d? print: %d == %d?".format(
            wordsSentToAddCheck, wordsAddChecked, wordsSentToUsageCheck,
            wordsUsageChecked, wordsSentToResultPrinter, resultsPrinted
          )
        )
      }
      if (
        wordsSentToAddCheck == wordsAddChecked &&
        wordsSentToUsageCheck == wordsUsageChecked &&
        wordsSentToResultPrinter == resultsPrinted
      ) {
        log.info("All work done. Shutting down.")
        context.system.shutdown()
      }
    }

    def receive = {
      case Start =>
        /*
         * Upon receiving the Start message, the master actor will generate all
         * possible 3-word sequences from its collection of words. It's at this
         * point that the Mastor actor will apply the allow-duplicate-operand
         * rule, if applicable.
         *
         * As a minor optimization, it will check that word1 != word3 (which
         * would imply that word2 is zero), and word2 != word3 (which would
         * imply word1 is zero).
         */
        log.info("Master received start message. Starting. Length of words is %d.".format(words.size))
        for (
          word1 <- words;
          word2 <- words;
          if (allowDuplicateOperands || word1 != word2);
          word3 <- words;
          if (word1 != word3);
          if (word2 != word3)
        ) {
          /*
           * TODO: Don't bother sending A+B=C and B+A=C, as the two are
           * equivalent, so we can save some CPU cycles.
           */
          sumCheckerRouter ! PotentialMatch(word1, word2, word3, None, None)
          wordsSentToAddCheck += 1
        }
        log.info("Master has finished sending out the wordlist.")
      case PotentialMatch(word1, word2, wordtotal, Some(solutionsFound), None) =>
        /*
         * This message should be sent by a SumChecker to inform the Master that
         * a sum verification is complete. The master checks there is at least
         * one solution. If not, processing for this PotentialMatch is finished.
         * If there is at least one solution, the allow-non-unique-solutions
         * rule is applied, and then the PotentialMatch is sent to the
         * FrequencyChecker.
         */
        if (solutionsFound.nonEmpty) {
          if (allowNonUniqueSolutions || solutionsFound.size == 1) {
            freqchecker ! PotentialMatch(word1, word2, wordtotal, Some(solutionsFound), None)
            wordsSentToUsageCheck += 1
          }
        }
      case PotentialMatch(word1, word2, wordtotal, Some(addProofs), Some(usageProof: String)) =>
        /**
         * This message should be sent by the FrequencyChecker to indicate it
         * found evidence of the three-word sequence used by some human (e.g.
         * in a tweet). In response, the Master actor will send the
         * PotentialMatch to the ResultPrinter for it to be displayed to the
         * user.
         */
        assert(addProofs.nonEmpty)
        resultPrinter ! PotentialMatch(word1, word2, wordtotal, Some(addProofs), Some(usageProof))
        wordsSentToResultPrinter += 1
      case AddChecked =>
        wordsAddChecked += 1
        checkShutdown()
      case UsageChecked =>
        wordsUsageChecked += 1
        checkShutdown()
      case ResultPrinted =>
        resultsPrinted += 1
        checkShutdown()
    }
  }

  /**
   * 
   */
  class ResultPrinter(appConf: Config) extends Actor with ActorLogging {
    val numSolutions: Int = appConf.getInt("max-solutions-to-print")
    def receive = {
      case PotentialMatch(word1, word2, word3, Some(addProofs), Some(usageProof)) =>
        if (addProofs.nonEmpty) {
          val addProofsString =
            addProofs.take(numSolutions).map(proof =>
              "%d + %d = %d".format(proof.operand1, proof.operand2, proof.total)
            ).mkString(", ")
          val moreStr = if (addProofs.size > numSolutions) ", ..." else ""
          println(
            "\n\t  %10s\n\t+ %10s\n\t============\n\t  %10s\nE.g. %s\nSolutions: %s%s\n"
            .format(word1, word2, word3, usageProof, addProofsString, moreStr)
          )
          sender ! ResultPrinted
        } else {
          log.error("Should not have sent %s %s %s if there are no add proofs.".format(word1, word2, word3))
        }
        
    }
  }

  class SumChecker(appConf: Config) extends Actor with ActorLogging {
    val logEntry = appConf.getBoolean("logging.sum-checker.entry")
    val logRecursiveAssignmentSearch = appConf.getBoolean("logging.sum-checker.recursive-assignment-search")
    val all10Digits = (0 until 10).toSet

    def uniqueLetters(words: String*): Set[Char] = {
      words.mkString("").toSet
    }

    val requirements: List[(String, String, String) => Boolean] = List(
      //10 or fewer distinct letters
      { (operand1: String, operand2: String, total: String) =>
        uniqueLetters(operand1, operand2, total).size <= 10
      },
      //total is distinct from both operands
      { (operand1: String, operand2: String, total: String) =>
        total != operand1 && total != operand2
      },
      /*
       * The number of "digits" in the two operands is less than or equal to the
       * number of "digits" in the total, and the total is no more than 1
       * "digit" bigger than either of the operands.
       */
      { (operand1: String, operand2: String, total: String) =>
        operand1.length <= total.length &&
        operand2.length <= total.length &&
        total.length <= math.max(operand1.length, operand2.length) + 1
      }
    )

    def wordToNumber(word: String, mapping: Map[Char, Int]): Long = {
      val numericWord: String = word.map({case char: Char =>
        ('0' + mapping(char)).toChar
      })
      numericWord.toLong
    }

    def getLegalAssignments(
      operand1: String, operand2: String, total: String,
      unassignedLetters: Set[Char], unassignedNumbers: Set[Int],
      mappingSoFar: Map[Char, Int], carry: Int
    ): Set[Map[Char, Int]] = {
      assert(carry >= 0, "Carry was %d.".format(carry))
      if (logRecursiveAssignmentSearch) {
        log.debug("Trying to find an assignment for %s + %s + %d = %s".format(operand1, operand2, carry, total))
      }
      def tryANumberFor(letter: Char): Set[Map[Char, Int]] = {
        (for (number <- unassignedNumbers) yield {
          getLegalAssignments(
            operand1, operand2, total,
            unassignedLetters - letter, unassignedNumbers - number,
            mappingSoFar + (letter -> number), carry
          )
        }).flatten
      }
      //Reject any solutions that assign 0 to the left-most character
      if (operand1.nonEmpty && mappingSoFar.get(operand1.head) == Some(0)) {
        Set.empty
      } else if (operand2.nonEmpty && mappingSoFar.get(operand2.head) == Some(0)) {
        Set.empty
      } else if (total.nonEmpty && mappingSoFar.get(total.head) == Some(0)) {
        Set.empty
      } else if (unassignedLetters.isEmpty) { //Base case: We have a full mapping; check if it's valid.
        val number1 = if (operand1.isEmpty) 0 else wordToNumber(operand1, mappingSoFar)
        val number2 = if (operand2.isEmpty) 0 else wordToNumber(operand2, mappingSoFar)
        val numberTotal = if (total.isEmpty) 0 else wordToNumber(total, mappingSoFar)
        if (number1 + number2 + carry == numberTotal) {
          if (logRecursiveAssignmentSearch) {
            log.debug("No more unassigned letters. Solution found.")
          }
          Set(mappingSoFar)
        } else {
          if (logRecursiveAssignmentSearch) {
            log.debug("No more unassigned letters. No solution found.")
          }
          Set.empty
        }
      } else if (operand1.nonEmpty && unassignedLetters.contains(operand1.last)) { //Try to assign rightmost letter in operand1
        if (logRecursiveAssignmentSearch) {
          log.debug("Attempting to assign right-most letter in %s.".format(operand1))
        }
        tryANumberFor(operand1.last)
      } else if (operand2.nonEmpty && unassignedLetters.contains(operand2.last)) { //Try to assign rightmost letter in operand2
        if (logRecursiveAssignmentSearch) {
          log.debug("Attempting to assign right-most letter in %s.".format(operand2))
        }
        tryANumberFor(operand2.last)
      } else if (unassignedLetters.contains(total.last)) { //We can determine what that letter must be
        val letter = total.last
        val operand1LastDigit = if (operand1.isEmpty) 0 else mappingSoFar(operand1.last)
        val operand2LastDigit = if (operand2.isEmpty) 0 else mappingSoFar(operand2.last)
        val sumOfLastDigits: Int = operand1LastDigit + operand2LastDigit + carry
        val lastDigitOfTotal: Int = sumOfLastDigits % 10
        val newCarry: Int = (sumOfLastDigits - lastDigitOfTotal) / 10
        val newOperand1 = if (operand1.isEmpty) "" else operand1.init
        val newOperand2 = if (operand2.isEmpty) "" else operand2.init
        assert(
          newCarry >= 0,
          "operand1LastDigit: %d operand2LastDigit: %d sumOfLastDigits: %d lastDigitOfTotal: %d newCarry: %d.".format(
            operand1LastDigit, operand2LastDigit, sumOfLastDigits, lastDigitOfTotal, newCarry
          )
        )
        if (unassignedNumbers.contains(lastDigitOfTotal)) {
          if (logRecursiveAssignmentSearch) {
            log.debug("Inferring that %s must be %d in %s.".format(letter, lastDigitOfTotal, total))
          }
          getLegalAssignments(
            newOperand1, newOperand2, total.init,
            unassignedLetters - letter, unassignedNumbers - lastDigitOfTotal,
            mappingSoFar + (letter -> lastDigitOfTotal), newCarry
          )
        } else {
          if (logRecursiveAssignmentSearch) {
            log.debug("Found contradiction: %s must be %d in %s, but that number is already used.".format(letter, lastDigitOfTotal, total))
          }
          Set.empty
        }
      } else { //We can check for a contradiction
        val letter = total.last
        val expectedNumber = mappingSoFar(letter)
        val operand1LastDigit = if (operand1.isEmpty) 0 else mappingSoFar(operand1.last)
        val operand2LastDigit = if (operand2.isEmpty) 0 else mappingSoFar(operand2.last)
        val sumOfLastDigits: Int = operand1LastDigit + operand2LastDigit + carry
        val actualNumber: Int = sumOfLastDigits % 10
        val newCarry: Int = (sumOfLastDigits - actualNumber) / 10
        assert(
          newCarry >= 0,
          "operand1LastDigit: %d operand2LastDigit: %d sumOfLastDigits: %d actualNumber: %d newCarry: %d.".format(
            operand1LastDigit, operand2LastDigit, sumOfLastDigits, actualNumber, newCarry
          )
        )
        val newOperand1 = if (operand1.isEmpty) "" else operand1.init
        val newOperand2 = if (operand2.isEmpty) "" else operand2.init
        if (expectedNumber == actualNumber) {
          if (logRecursiveAssignmentSearch) {
            log.debug("Verified that %s is %d in %s.".format(letter, expectedNumber, total))
          }
          getLegalAssignments(
            newOperand1, newOperand2, total.init,
            unassignedLetters, unassignedNumbers,
            mappingSoFar, newCarry
          )
        } else {
          if (logRecursiveAssignmentSearch) {
            log.debug("Found contradiction when %s is both %d and %d in %s.".format(letter, expectedNumber, actualNumber, total))
          }
          Set.empty
        }
      }
    }

    def receive = {
      case PotentialMatch(operand1, operand2, total, _, maybeFreq) =>
        if (logEntry) {
          log.debug("SumChecker received %s + %s = %s?".format(operand1, operand2, total))
        }
        if (requirements.forall(predicate => predicate(operand1, operand2, total))) {
          //check that some permutation of letter assignment makes a valid sum
          log.debug("Checking that %s + %s = %s".format(operand1, operand2, total))
          val letters: Set[Char] = uniqueLetters(operand1, operand2, total)
          val addProofs: Set[AddProof] =
            for (
              assignment <- getLegalAssignments(
                operand1, operand2, total,
                letters, all10Digits,
                Map.empty, 0
              )
            ) yield {
              val number1 = wordToNumber(operand1, assignment)
              val number2 = wordToNumber(operand2, assignment)
              val numberTotal = wordToNumber(total, assignment)
              AddProof(number1, number2, numberTotal)
            }
          sender ! PotentialMatch(operand1, operand2, total, Some(addProofs), maybeFreq)
        } else {
          sender ! PotentialMatch(operand1, operand2, total, None, maybeFreq)
        }
        sender ! AddChecked
    }
  }

  class FrequencyChecker(appConf: Config) extends Actor with ActorLogging {
    import java.net._

    import oauth.signpost._
    import oauth.signpost.basic._

    val twitterConf = appConf.getConfig("twitter-authentication")

    val consumer = new DefaultOAuthConsumer(
      twitterConf.getString("consumer-key"),
      twitterConf.getString("consumer-secret")
    )
    consumer.setTokenWithSecret(
      twitterConf.getString("access-token"),
      twitterConf.getString("access-token-secret")
    )
    val provider = new DefaultOAuthProvider(
      "https://api.twitter.com/oauth/request_token",
      "https://api.twitter.com/oauth/access_token",
      "https://api.twitter.com/oauth/authorize"
    )

    val cache = scala.collection.mutable.Map.empty[(String,String,String), Option[String]]

    def receive = {
      case PotentialMatch(word1, word2, word3, maybeAddProofs, None) =>
        val exampleUsage: Option[String] = cache.getOrElse((word1, word2, word3), {
          log.debug("FrequencyChecker cache miss. Perform Twitter API query.")
          import java.net.URLEncoder
          val encodedWord1 = URLEncoder.encode(word1, "UTF-8")
          val encodedWord2 = URLEncoder.encode(word2, "UTF-8")
          val encodedWord3 = URLEncoder.encode(word3, "UTF-8")
          val url = new URL(
            "https://api.twitter.com/1.1/search/tweets.json?q=%%22%s%%20%s%%20%s%%22".format(encodedWord1, encodedWord2, encodedWord3)
          )
          val request: HttpURLConnection = url.openConnection().asInstanceOf[HttpURLConnection]
          consumer.sign(request)
          request.connect()
          request.getResponseCode match {
            case HttpURLConnection.HTTP_OK =>
              import net.liftweb.json._
              implicit val formats = net.liftweb.json.DefaultFormats 
              val inputStream = request.getInputStream()
              val strResponse: String = Source.fromInputStream(inputStream).mkString("")
              inputStream.close()
              val jsonResponse = net.liftweb.json.parse(strResponse)
              val statuses: List[JValue] = (jsonResponse \ "statuses").asInstanceOf[JArray].arr
              val exampleUsage: Option[String] = statuses.toList.map({case status: JValue =>
                (status \ "text").extract[String]
              }).find({case tweet: String =>
                tweet.toUpperCase().contains("%s %s %s".format(word1, word2, word3))
              })
              //TODO: Ignore punctuation; collapse multiple spaces
              exampleUsage
            case HttpURLConnection.HTTP_UNAUTHORIZED =>
              val errorStream = request.getErrorStream()
              val strResponse: String = Source.fromInputStream(errorStream).mkString("")
              log.error(
                "Got response code %d %s from Twitter API. Request URL was %s. Server responded %s.".format(
                  request.getResponseCode, request.getResponseMessage, request.getURL, strResponse
                )
              )
              context.system.shutdown()
              None
            case 429 => //Too Many Requests
              val minutesToWait = 15
              log.info(
                "Hit Twitter API limit while querying %s %s %s. Waiting %d minutes before querying again.".format(
                  word1, word2, word3, minutesToWait
                )
              )
              Thread.sleep(1000 * 60 * minutesToWait)
              None //TODO: I don't actually want to store this in the cache; need to think of another way to do this
          }
        })
        if (exampleUsage.isDefined) {
          log.debug("Found example usage of %s %s %s on Twitter.".format(word1, word2, word3))
          sender ! PotentialMatch(word1, word2, word3, maybeAddProofs, exampleUsage)
        } else {
          val proofString: String = maybeAddProofs match {
            case Some(addProofs) if addProofs.nonEmpty =>
              val proof = addProofs.head
              "(%s %s %s)".format(proof.operand1, proof.operand2, proof.total)
            case None =>
              ""
          }
          log.debug(
            "Found no usage of %s %s %s %s on Twitter.".format(
              word1, word2, word3, proofString
            )
          )
        }
        sender ! UsageChecked
    }
  }
}